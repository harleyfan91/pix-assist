import React, { useState, useEffect } from "react"
import { View, ViewStyle, TouchableOpacity } from "react-native"
import { Ionicons } from "@expo/vector-icons"
import { useNavigation } from "@react-navigation/native"
import { useSafeAreaInsets } from "react-native-safe-area-context"
import { Gesture, GestureDetector } from "react-native-gesture-handler"
import Reanimated, { 
  runOnJS, 
  useSharedValue, 
  useAnimatedStyle, 
  useDerivedValue,
  withSpring,
  interpolate,
  Extrapolate
} from "react-native-reanimated"
import { AppStackScreenProps } from "@/navigators/AppNavigator"

interface TopNavigationProps {
  onNavigationStateChange?: (isOpen: boolean) => void
  onProgressChange?: (progress: number) => void
}

export const TopNavigation: React.FC<TopNavigationProps> = ({ onNavigationStateChange, onProgressChange }) => {
  const navigation = useNavigation<AppStackScreenProps<"Camera">["navigation"]>()
  const insets = useSafeAreaInsets()
  const [isOpen, setIsOpen] = useState(false)

  // Shared values for fluid animation
  const translateY = useSharedValue(0)
  const gestureProgress = useSharedValue(0) // 0 = closed, 1 = open
  const drawerHeight = useSharedValue(80) // Direct height control

  // Notify parent component when navigation state changes
  useEffect(() => {
    onNavigationStateChange?.(isOpen)
  }, [isOpen, onNavigationStateChange])

  // Track progress changes and notify parent
  useDerivedValue(() => {
    runOnJS(onProgressChange || (() => {}))(gestureProgress.value)
  }, [gestureProgress, onProgressChange])

  const handleNavigation = (screenName: "Home" | "Gallery" | "Settings") => {
    navigation.navigate(screenName as any)
    setIsOpen(false) // Close navigation after selection
  }

  const handleToggle = (newState: boolean) => {
    setIsOpen(newState)
    
    // Animate to the new state with spring
    const targetProgress = newState ? 1 : 0
    gestureProgress.value = withSpring(targetProgress, {
      damping: 20,
      stiffness: 300,
    })
  }

  // Pan gesture for fluid swipe tracking
  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      'worklet'
      const { translationY } = event
      
      // Direct mapping: finger position directly controls drawer height
      // Positive translationY = swiping down (opening)
      // Negative translationY = swiping up (closing)
      const minHeight = 80  // Collapsed height
      const maxHeight = 160 // Expanded height
      const heightRange = maxHeight - minHeight
      
      // Calculate new height based on gesture start position and current translation
      const startHeight = isOpen ? maxHeight : minHeight
      const newHeight = Math.max(minHeight, Math.min(maxHeight, startHeight + translationY))
      
      // Update height directly
      drawerHeight.value = newHeight
      
      // Update progress for other animations (opacity, rotation)
      gestureProgress.value = (newHeight - minHeight) / heightRange
      translateY.value = translationY
    })
    .onEnd((event) => {
      'worklet'
      const { translationY, velocityY } = event
      const currentProgress = gestureProgress.value
      
      // Determine final state based on progress and velocity
      let targetProgress = 0
      let shouldOpen = false
      
      if (currentProgress > 0.5) {
        // More than halfway open
        targetProgress = 1
        shouldOpen = true
      } else if (currentProgress < 0.5) {
        // Less than halfway open
        targetProgress = 0
        shouldOpen = false
      } else {
        // Exactly halfway - use velocity to decide
        if (velocityY > 0) {
          // Positive velocity (swiping down)
          targetProgress = 1
          shouldOpen = true
        } else {
          // Negative velocity (swiping up)
          targetProgress = 0
          shouldOpen = false
        }
      }
      
      // Animate to final state
      const minHeight = 80
      const maxHeight = 160
      const targetHeight = shouldOpen ? maxHeight : minHeight
      
      drawerHeight.value = withSpring(targetHeight, {
        damping: 20,
        stiffness: 300,
      })
      
      gestureProgress.value = withSpring(targetProgress, {
        damping: 20,
        stiffness: 300,
      })
      translateY.value = withSpring(0, {
        damping: 20,
        stiffness: 300,
      })
      
      // Update state if changed
      if (shouldOpen !== isOpen) {
        runOnJS(handleToggle)(shouldOpen)
      }
    })

  // Animated styles for fluid transitions
  const animatedNavigationStyle = useAnimatedStyle(() => {
    const opacity = interpolate(
      gestureProgress.value,
      [0, 0.2, 1],
      [0, 0.5, 1],
      Extrapolate.CLAMP
    )
    
    return {
      opacity,
      // Remove translateY - icons stay within drawer boundaries
    }
  })

  // Animated container style for dynamic height - direct mapping
  const animatedContainerStyle = useAnimatedStyle(() => {
    return {
      height: drawerHeight.value,
    }
  })

  const animatedHandleStyle = useAnimatedStyle(() => {
    return {
      // No animations - handle stays static
    }
  })

  return (
    <>
      {/* Transparent overlay to close drawer when tapping outside */}
      {isOpen && (
        <TouchableOpacity 
          style={$overlay}
          onPress={() => handleToggle(false)}
          activeOpacity={1}
        />
      )}
      
      <GestureDetector gesture={panGesture}>
        <Reanimated.View style={[$topNavigation, { paddingTop: insets.top + 4 }, animatedContainerStyle]}>
          {/* Touchable area to close drawer when tapping on background */}
          <TouchableOpacity 
            style={$drawerBackground}
            onPress={() => isOpen && handleToggle(false)}
            activeOpacity={1}
          />
        {/* Navigation Icons - Animated */}
        <Reanimated.View style={[animatedNavigationStyle]}>
          <View style={$navigationIcons}>
            <TouchableOpacity 
              style={$navButton} 
              onPress={() => handleNavigation("Home")}
            >
              <Ionicons name="home" size={24} color="#fff" />
            </TouchableOpacity>

            <TouchableOpacity 
              style={$navButton} 
              onPress={() => handleNavigation("Gallery")}
            >
              <Ionicons name="images" size={24} color="#fff" />
            </TouchableOpacity>

            <TouchableOpacity 
              style={$navButton} 
              onPress={() => handleNavigation("Settings")}
            >
              <Ionicons name="settings" size={24} color="#fff" />
            </TouchableOpacity>
          </View>
        </Reanimated.View>

        {/* Handle - Always visible with animation */}
        <TouchableOpacity 
          style={$handleButton} 
          onPress={() => handleToggle(!isOpen)}
        >
          <Reanimated.View style={animatedHandleStyle}>
            <View style={$handleBar} />
          </Reanimated.View>
        </TouchableOpacity>
        </Reanimated.View>
      </GestureDetector>
    </>
  )
}

// Styles
const $topNavigation: ViewStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  backgroundColor: "rgba(0, 0, 0, 0.95)", // Slightly more opaque
  borderBottomLeftRadius: 20,
  borderBottomRightRadius: 20,
  paddingHorizontal: 20,
  paddingBottom: 4, // Reduced padding to give more space for content
  zIndex: 1000,
  // Add subtle shadow for depth
  shadowColor: "#000",
  shadowOffset: { width: 0, height: 4 },
  shadowOpacity: 0.3,
  shadowRadius: 8,
  elevation: 8, // Android shadow
  // Height will be controlled by animatedContainerStyle
}

const $navigationIcons: ViewStyle = {
  flexDirection: "row",
  justifyContent: "space-around",
  alignItems: "center",
  paddingTop: 12, // Reduced padding
  paddingBottom: 12, // Increased space between icons and handle
}


const $handleButton: ViewStyle = {
  paddingVertical: 12,
  paddingHorizontal: 20,
  alignItems: "center",
  justifyContent: "center",
  position: "absolute",
  bottom: 0,
  left: 0,
  right: 0,
}

const $handleBar: ViewStyle = {
  width: 36, // Slightly wider
  height: 4, // Slightly taller
  backgroundColor: "#fff",
  borderRadius: 2,
  // Add subtle shadow for depth
  shadowColor: "#000",
  shadowOffset: { width: 0, height: 1 },
  shadowOpacity: 0.2,
  shadowRadius: 2,
  elevation: 1,
}

const $navButton: ViewStyle = {
  padding: 12,
  alignItems: "center",
  justifyContent: "center",
  minWidth: 60,
  // Clean icons on black background - no borders or backgrounds
}

const $overlay: ViewStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  backgroundColor: "transparent",
  zIndex: 999, // Below the drawer but above everything else
}

const $drawerBackground: ViewStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  backgroundColor: "transparent",
  zIndex: 1, // Above the drawer background but below icons
}